import React, { useCallback, useEffect, useState } from 'react';
import ReactFlow, {
  Node,
  Edge,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
  MarkerType,
  Position,
  MiniMap,
} from 'reactflow';
import 'reactflow/dist/style.css';
import { PipelineStep } from '@/types';

interface GraphVisualizationProps {
  steps: PipelineStep[];
}

// Color scheme for different node types
const NODE_COLORS = {
  q0: '#3b82f6',           // Blue - Goal
  goal: '#8b5cf6',         // Purple - Goal Pillars
  fcc: '#ec4899',          // Pink - Failure Channels
  spv: '#f59e0b',          // Amber - System Properties
  ra: '#10b981',           // Green - Requirement Atoms
  scientific: '#06b6d4',   // Cyan - Scientific Pillars
  edge: '#6366f1',         // Indigo - Matching Edges
  l3: '#ef4444',           // Red - L3 Questions
  ih: '#f97316',           // Orange - Instantiation Hypotheses
  l4: '#84cc16',           // Lime - L4 Questions
  l6: '#14b8a6',           // Teal - L6 Tasks
};

export const GraphVisualization: React.FC<GraphVisualizationProps> = ({ steps }) => {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [selectedNode, setSelectedNode] = useState<any>(null);

  const buildGraph = useCallback(() => {
    const newNodes: Node[] = [];
    const newEdges: Edge[] = [];
    
    // Force-directed layout parameters
    const clusterSpacing = 800; // Space between major clusters
    const nodeSpacing = 150; // Space between nodes in a cluster
    const randomOffset = () => (Math.random() - 0.5) * 100; // Natural variation

    // Center point for the entire graph
    const centerX = 0;
    const centerY = 0;
    
    // Step 1: Q0 (Master Question) - Center of the universe
    const step1 = steps.find(s => s.id === 1);
    if (step1?.output) {
      newNodes.push({
        id: 'q0',
        type: 'default',
        position: { x: centerX, y: centerY },
        data: { 
          label: 'Q₀: Master Question',
          fullData: step1.output,
          type: 'q0'
        },
        style: {
          background: NODE_COLORS.q0,
          color: 'white',
          border: '2px solid #1e40af',
          borderRadius: '8px',
          padding: '10px',
          fontSize: '14px',
          fontWeight: 'bold',
          width: 200,
        },
      });
    }

    // Step 2: Goal Pillars - Radial layout around Q0
    const step2 = steps.find(s => s.id === 2);
    if (step2?.output) {
      const goals = step2.output.goals || step2.output.Goal_Pillars || step2.output.goal_pillars || [];
      const bridgeLexicon = step2.output.bridge_lexicon || step2.output.Bridge_Lexicon || step2.output.bridgeLexicon || {};
      
      // Position goals in a circle around Q0
      const goalRadius = clusterSpacing * 0.8;
      goals.forEach((goal: any, idx: number) => {
        const angle = (idx / goals.length) * 2 * Math.PI;
        const nodeId = `goal-${goal.id}`;
        const xPos = centerX + Math.cos(angle) * goalRadius + randomOffset();
        const yPos = centerY + Math.sin(angle) * goalRadius + randomOffset();
        
        newNodes.push({
          id: nodeId,
          type: 'default',
          position: { x: xPos, y: yPos },
          data: { 
            label: `${goal.id}: ${goal.title}`,
            fullData: goal,
            type: 'goal'
          },
          style: {
            background: NODE_COLORS.goal,
            color: 'white',
            border: '2px solid #6d28d9',
            borderRadius: '12px',
            padding: '12px',
            fontSize: '13px',
            width: 200,
            boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
          },
        });

        // Connect to Q0 with curved edges
        if (step1?.output) {
          newEdges.push({
            id: `q0-${nodeId}`,
            source: 'q0',
            target: nodeId,
            type: 'default',
            animated: true,
            style: { stroke: NODE_COLORS.goal, strokeWidth: 3, opacity: 0.6 },
            markerEnd: { type: MarkerType.ArrowClosed, color: NODE_COLORS.goal },
          });
        }
      });

      // Bridge Lexicon - Scattered around the periphery
      const fccs = bridgeLexicon.failure_channels || bridgeLexicon.Failure_Channels || [];
      const spvs = bridgeLexicon.system_properties || bridgeLexicon.System_Properties || [];
      
      // Position FCCs in outer ring
      const fccRadius = clusterSpacing * 1.5;
      fccs.slice(0, 8).forEach((fcc: any, idx: number) => {
        const angle = (idx / 8) * 2 * Math.PI + Math.PI / 8;
        const nodeId = `fcc-${fcc.id || fcc.ID}`;
        const xPos = centerX + Math.cos(angle) * fccRadius + randomOffset() * 2;
        const yPos = centerY + Math.sin(angle) * fccRadius + randomOffset() * 2;
        
        newNodes.push({
          id: nodeId,
          type: 'default',
          position: { x: xPos, y: yPos },
          data: { 
            label: fcc.name || fcc.Name,
            fullData: fcc,
            type: 'fcc'
          },
          style: {
            background: NODE_COLORS.fcc,
            color: 'white',
            border: '1px solid #be185d',
            borderRadius: '8px',
            padding: '8px',
            fontSize: '10px',
            width: 130,
            opacity: 0.9,
          },
        });
        
        // Connect FCCs to their associated Goals with subtle edges
        goals.forEach((goal: any) => {
          const goalFCCs = goal.bridge_tags?.failure_channels || [];
          if (goalFCCs.includes(fcc.id || fcc.ID)) {
            newEdges.push({
              id: `${nodeId}-goal-${goal.id}`,
              source: nodeId,
              target: `goal-${goal.id}`,
              type: 'default',
              style: { stroke: NODE_COLORS.fcc, strokeWidth: 1, strokeDasharray: '3,3', opacity: 0.3 },
            });
          }
        });
      });

      // Add a few key SPVs - same level as FCCs
      spvs.slice(0, 4).forEach((spv: any, idx: number) => {
        const nodeId = `spv-${spv.id || spv.ID}`;
        newNodes.push({
          id: nodeId,
          type: 'default',
          position: { x: 650 + idx * 150, y: lexiconY },
          data: { 
            label: spv.name || spv.Name,
            fullData: spv,
            type: 'spv'
          },
          style: {
            background: NODE_COLORS.spv,
            color: 'white',
            border: '1px solid #b45309',
            borderRadius: '6px',
            padding: '6px',
            fontSize: '10px',
            width: 120,
          },
        });
        
        // Connect SPVs to their associated Goals (will connect to RAs later if they exist)
        goals.forEach((goal: any) => {
          const goalSPVs = goal.bridge_tags?.system_properties_required || [];
          const hasSPV = goalSPVs.some((sp: any) => sp.spv_id === (spv.id || spv.ID));
          if (hasSPV) {
            newEdges.push({
              id: `${nodeId}-goal-${goal.id}`,
              source: nodeId,
              target: `goal-${goal.id}`,
              type: 'smoothstep',
              animated: true,
              style: { stroke: NODE_COLORS.spv, strokeWidth: 1, strokeDasharray: '5,5' },
              markerEnd: { type: MarkerType.ArrowClosed, color: NODE_COLORS.spv },
            });
          }
        });
      });

      yOffset += ySpacing;
    }

    // Step 3: Requirement Atoms (organized by parent goal) - all at same Y level
    const step3 = steps.find(s => s.id === 3);
    if (step3?.output && typeof step3.output === 'object') {
      const rasByGoal = step3.output;
      const raY = yOffset; // All RAs at same level
      let totalRaCount = 0;
      
      // Process each goal's RAs
      Object.keys(rasByGoal).forEach((goalId) => {
        const ras = Array.isArray(rasByGoal[goalId]) ? rasByGoal[goalId] : [];
        const parentGoalNode = `goal-${goalId}`;
        
        // Find parent goal position to align RAs below it
        const parentNode = newNodes.find(n => n.id === parentGoalNode);
        const baseX = parentNode ? parentNode.position.x : 100 + (totalRaCount * 200);
        
        // Limit to 3 RAs per goal for clarity
        ras.slice(0, 3).forEach((ra: any, raIdx: number) => {
          if (!ra || typeof ra !== 'object') return;
          
          const nodeId = `ra-${ra.ra_id || `${goalId}-${raIdx}`}`;
          const xPos = baseX + (raIdx - 1) * 200; // Increased spacing to prevent overlap
          
          newNodes.push({
            id: nodeId,
            type: 'default',
            position: { x: xPos, y: raY },
            data: { 
              label: `${ra.ra_id || 'RA'}: ${(ra.atom_title || ra.title || 'Untitled').substring(0, 30)}`,
              fullData: ra,
              type: 'ra',
              parentGoalId: goalId
            },
            style: {
              background: NODE_COLORS.ra,
              color: 'white',
              border: '1px solid #059669',
              borderRadius: '6px',
              padding: '8px',
              fontSize: '10px',
              width: 150,
            },
          });

          // Connect to parent goal
          if (parentNode) {
            newEdges.push({
              id: `${parentGoalNode}-${nodeId}`,
              source: parentGoalNode,
              target: nodeId,
              type: 'smoothstep',
              animated: true,
              style: { stroke: NODE_COLORS.ra, strokeWidth: 1.5, strokeDasharray: '5,5' },
              markerEnd: { type: MarkerType.ArrowClosed, color: NODE_COLORS.ra },
            });
          }
          
          // Connect SPVs to RAs instead of Goals if RAs exist
          const spvNodes = newNodes.filter(n => n.data.type === 'spv');
          spvNodes.forEach(spvNode => {
            // Remove SPV->Goal edge if it exists
            const oldEdgeId = `${spvNode.id}-${parentGoalNode}`;
            const edgeIndex = newEdges.findIndex(e => e.id === oldEdgeId);
            if (edgeIndex !== -1) {
              newEdges.splice(edgeIndex, 1);
              
              // Add SPV->RA edge instead
              newEdges.push({
                id: `${spvNode.id}-${nodeId}`,
                source: spvNode.id,
                target: nodeId,
                type: 'smoothstep',
                animated: true,
                style: { stroke: NODE_COLORS.spv, strokeWidth: 1, strokeDasharray: '5,5' },
                markerEnd: { type: MarkerType.ArrowClosed, color: NODE_COLORS.spv },
              });
            }
          });
        });
        
        totalRaCount += Math.min(ras.length, 3);
      });
      
      yOffset += ySpacing;
    }

    // Step 4: Scientific Pillars
    const step4 = steps.find(s => s.id === 4);
    if (step4?.output) {
      const scientificPillars = step4.output.scientific_pillars || step4.output.Scientific_Pillars || step4.output.scientificPillars || [];
      
      const sciY = yOffset; // All scientific pillars at same level
      scientificPillars.slice(0, 6).forEach((pillar: any, idx: number) => {
        if (!pillar || typeof pillar !== 'object') return;
        
        const nodeId = `s-${pillar.id}`;
        const xPos = 100 + idx * xSpacing;
        
        // Extract capabilities/SPVs for tooltip
        const capabilities = pillar.capabilities || [];
        const spvIds = capabilities.map((cap: any) => cap.spv_id).filter(Boolean);
        
        newNodes.push({
          id: nodeId,
          type: 'default',
          position: { x: xPos, y: sciY },
          data: { 
            label: `${pillar.id}: ${(pillar.title || 'Untitled').substring(0, 25)}`,
            fullData: {
              ...pillar,
              spv_ids: spvIds,
              capability_count: capabilities.length
            },
            type: 'scientific'
          },
          style: {
            background: NODE_COLORS.scientific,
            color: 'white',
            border: '2px solid #0891b2',
            borderRadius: '8px',
            padding: '10px',
            fontSize: '11px',
            width: 180,
          },
        });
        
        // Connect scientific pillars to RAs based on SPV capabilities
        const raNodes = newNodes.filter(n => n.data.type === 'ra');
        capabilities.forEach((capability: any) => {
          const spvId = capability.spv_id;
          if (spvId) {
            raNodes.forEach(_raNode => {
              // Check if this RA is associated with this SPV
              // Connect if there's a logical relationship (simplified for now)
              // You can enhance this logic based on your specific requirements
            });
          }
        });
      });
      
      yOffset += ySpacing; // Move to next level
    }

    // Step 5: Matching Edges (Goal → Scientific Pillar connections)
    const step5 = steps.find(s => s.id === 5);
    if (step5?.output) {
      const matchingData = step5.output;
      Object.keys(matchingData).forEach((goalId) => {
        const goalData = matchingData[goalId];
        const edgesData = goalData?.edges || [];
        
        edgesData.forEach((edgeData: any) => {
          if (!edgeData || typeof edgeData !== 'object') return;
          
          const sourceNode = `s-${edgeData.source_s_id}`;
          const targetNode = `goal-${goalId}`;
          
          if (newNodes.find(n => n.id === sourceNode) && newNodes.find(n => n.id === targetNode)) {
            // Different styles for different relationship types
            let edgeColor, strokeWidth, dashArray, animated;
            
            switch (edgeData.relationship) {
              case 'solves':
                edgeColor = '#10b981'; // Green - fully solves
                strokeWidth = 3;
                dashArray = '0'; // Solid line
                animated = true;
                break;
              case 'partially_solves':
                edgeColor = '#f59e0b'; // Amber - partial solution
                strokeWidth = 2.5;
                dashArray = '8,4'; // Dashed
                animated = true;
                break;
              case 'enables_measurement_for':
                edgeColor = '#3b82f6'; // Blue - enables measurement
                strokeWidth = 2;
                dashArray = '4,4'; // Short dashes
                animated = false;
                break;
              case 'proxies_for':
                edgeColor = '#8b5cf6'; // Purple - proxy relationship
                strokeWidth = 1.5;
                dashArray = '2,3'; // Dotted
                animated = false;
                break;
              case 'violates':
                edgeColor = '#ef4444'; // Red - violates
                strokeWidth = 2;
                dashArray = '10,5'; // Long dashes
                animated = true;
                break;
              default:
                edgeColor = '#6366f1'; // Indigo - other
                strokeWidth = 2;
                dashArray = '5,5';
                animated = true;
            }
            
            newEdges.push({
              id: `match-${sourceNode}-${targetNode}`,
              source: sourceNode,
              target: targetNode,
              type: 'smoothstep',
              animated: animated,
              label: edgeData.relationship?.replace(/_/g, ' '),
              style: { 
                stroke: edgeColor, 
                strokeWidth: strokeWidth, 
                strokeDasharray: dashArray 
              },
              markerEnd: { type: MarkerType.ArrowClosed, color: edgeColor },
              data: { 
                fullData: edgeData, 
                type: 'matching_edge',
                confidence: edgeData.confidence_score,
                gap: edgeData.gap_analysis?.primary_delta
              },
            });
          }
        });
      });
    }

    // Step 6: L3 Questions - Hierarchical clustering under Goals
    const step6 = steps.find(s => s.id === 6);
    if (step6?.output) {
      let l3Questions: any[] = [];
      
      if (Array.isArray(step6.output)) {
        l3Questions = step6.output;
      } else if (step6.output && typeof step6.output === 'object') {
        if (step6.output.l3_questions) {
          l3Questions = Array.isArray(step6.output.l3_questions) ? step6.output.l3_questions : [];
        } else if (step6.output.seed_questions) {
          l3Questions = Array.isArray(step6.output.seed_questions) ? step6.output.seed_questions : [];
        } else {
          l3Questions = Object.values(step6.output).filter(val => Array.isArray(val)).flat();
        }
      }
      
      // Group L3s by their parent Goal
      const l3sByGoal: Record<string, any[]> = {};
      
      l3Questions.forEach((q: any) => {
        if (!q || typeof q !== 'object') return;
        const l3Id = q.id || '';
        let parentGoalId = null;
        
        // Try new format first: Q_L3_M_G1_1, Q_L3_M_G2_1
        const newFormatMatch = l3Id.match(/Q_L3_(M_G\d+)_/);
        if (newFormatMatch) {
          parentGoalId = newFormatMatch[1];
        }
        // Legacy format fallbacks
        else if (l3Id.includes('_FRAG_')) parentGoalId = 'M_G1';
        else if (l3Id.match(/_MG(\d+)_/)) {
          const match = l3Id.match(/_MG(\d+)_/);
          if (match) parentGoalId = `M_G${match[1]}`;
        } else if (l3Id.match(/Q_L3_003_/)) parentGoalId = 'M_G3';
        else if (l3Id.match(/Q_L3_001_/)) parentGoalId = 'M_G4';
        else if (l3Id.match(/Q_L3_007_/)) parentGoalId = 'M_G5';
        else if (l3Id.match(/Q_L3_006_/)) parentGoalId = 'M_G6';
        
        if (parentGoalId) {
          if (!l3sByGoal[parentGoalId]) l3sByGoal[parentGoalId] = [];
          l3sByGoal[parentGoalId].push(q);
        }
      });
      
      const l3Y = yOffset;
      
      // For each Goal, place its L3s in a cluster below it
      Object.keys(l3sByGoal).forEach((goalId) => {
        const goalL3s = l3sByGoal[goalId];
        const parentGoalNode = newNodes.find(n => n.id === `goal-${goalId}`);
        
        if (!parentGoalNode) return;
        
        // Position L3s in a compact cluster under the parent Goal
        const baseX = parentGoalNode.position.x;
        const l3sPerRow = 3; // 3 L3s per row for compact clustering
        
        goalL3s.slice(0, 5).forEach((q: any, idx: number) => {
          const nodeId = `l3-${q.id || idx}`;
          
          // Arrange in compact grid under parent
          const row = Math.floor(idx / l3sPerRow);
          const col = idx % l3sPerRow;
          const xPos = baseX - 100 + col * 120; // Compact horizontal spacing
          const yPos = l3Y + row * 100; // Compact vertical spacing
        
        newNodes.push({
          id: nodeId,
          type: 'default',
          position: { x: xPos, y: yPos },
          data: { 
            label: `L3: ${q.text?.substring(0, 35)}...`,
            fullData: q,
            type: 'l3'
          },
          style: {
            background: NODE_COLORS.l3,
            color: 'white',
            border: '2px solid #b91c1c',
            borderRadius: '8px',
            padding: '10px',
            fontSize: '11px',
            width: 180,
          },
        });
        
        // Create edge to parent Goal
        newEdges.push({
          id: `goal-${goalId}-${nodeId}`,
          source: `goal-${goalId}`,
          target: nodeId,
          type: 'smoothstep',
          animated: true,
          style: { stroke: NODE_COLORS.l3, strokeWidth: 1.5, strokeDasharray: '3,3' },
          markerEnd: { type: MarkerType.ArrowClosed, color: NODE_COLORS.l3 },
        });
        });
      });
      
      // Adjust yOffset - find the maximum Y position used
      const maxL3Rows = Math.max(...Object.values(l3sByGoal).map(l3s => Math.ceil(l3s.length / 3)));
      yOffset += ySpacing + (maxL3Rows - 1) * 100;
    }

    // Step 7: Instantiation Hypotheses - Hierarchical clustering under L3s
    const step7 = steps.find(s => s.id === 7);
    if (step7?.output) {
      let ihs: any[] = [];
      
      if (Array.isArray(step7.output)) {
        ihs = step7.output;
      } else if (step7.output && typeof step7.output === 'object') {
        ihs = Object.values(step7.output).filter(val => Array.isArray(val)).flat();
      }
      
      // Group IHs by their parent L3 question
      const ihsByL3: Record<string, any[]> = {};
      
      ihs.forEach((ih: any) => {
        if (!ih || typeof ih !== 'object') return;
        const ihId = ih.ih_id || '';
        
        // Extract L3 ID from IH ID format: IH_Q_L3_M_G1_1_01 -> Q_L3_M_G1_1
        const l3Match = ihId.match(/IH_(Q_L3_[^_]+_[^_]+_\d+)/);
        if (l3Match) {
          const parentL3Id = l3Match[1];
          if (!ihsByL3[parentL3Id]) ihsByL3[parentL3Id] = [];
          ihsByL3[parentL3Id].push(ih);
        }
      });
      
      const ihY = yOffset;
      
      // For each L3, place its IHs in a cluster below it
      Object.keys(ihsByL3).forEach((l3Id) => {
        const l3IHs = ihsByL3[l3Id];
        const parentL3Node = newNodes.find(n => n.id === `l3-${l3Id}`);
        
        if (!parentL3Node) return;
        
        // Position IHs in a compact cluster under the parent L3
        const baseX = parentL3Node.position.x;
        const ihsPerRow = 2; // 2 IHs per row for compact clustering
        
        l3IHs.forEach((ih: any, idx: number) => {
          const nodeId = `ih-${ih.ih_id || idx}`;
          
          // Arrange in compact grid under parent
          const row = Math.floor(idx / ihsPerRow);
          const col = idx % ihsPerRow;
          const xPos = baseX - 50 + col * 110; // Compact horizontal spacing
          const yPos = ihY + row * 90; // Compact vertical spacing
          
          newNodes.push({
            id: nodeId,
            type: 'default',
            position: { x: xPos, y: yPos },
            data: { 
              label: `IH: ${ih.process_hypothesis?.substring(0, 25)}...`,
              fullData: ih,
              type: 'ih'
            },
            style: {
              background: NODE_COLORS.ih,
              color: 'white',
              border: '1px solid #c2410c',
              borderRadius: '6px',
              padding: '6px',
              fontSize: '9px',
              width: 100,
            },
          });
          
          // Create edge to parent L3
          newEdges.push({
            id: `l3-${l3Id}-${nodeId}`,
            source: `l3-${l3Id}`,
            target: nodeId,
            type: 'smoothstep',
            animated: true,
            style: { stroke: NODE_COLORS.ih, strokeWidth: 1, strokeDasharray: '2,2' },
            markerEnd: { type: MarkerType.ArrowClosed, color: NODE_COLORS.ih },
          });
        });
      });
      
      // Adjust yOffset - find the maximum Y position used
      const maxIHRows = Math.max(...Object.values(ihsByL3).map(ihs => Math.ceil(ihs.length / 2)));
      yOffset += ySpacing + (maxIHRows - 1) * 90;
    }

    // Step 8: L4 Questions - Hierarchical clustering under IH nodes
    const step8 = steps.find(s => s.id === 8);
    if (step8?.output) {
      let l4Questions: any[] = [];
      
      if (Array.isArray(step8.output)) {
        l4Questions = step8.output;
      } else if (step8.output && typeof step8.output === 'object') {
        if (step8.output.l4_questions) {
          l4Questions = Array.isArray(step8.output.l4_questions) ? step8.output.l4_questions : [];
        } else {
          l4Questions = Object.values(step8.output).filter(val => Array.isArray(val)).flat();
        }
      }
      
      // Group L4s by their parent IH (based on distinguishes_ih_ids)
      const l4sByIH: Record<string, any[]> = {};
      
      l4Questions.forEach((q: any) => {
        if (!q || typeof q !== 'object') return;
        // Use first IH from distinguishes_ih_ids as parent
        const parentIHIds = q.distinguishes_ih_ids || [];
        if (parentIHIds.length > 0) {
          const parentIHId = parentIHIds[0];
          if (!l4sByIH[parentIHId]) l4sByIH[parentIHId] = [];
          l4sByIH[parentIHId].push(q);
        }
      });
      
      const l4Y = yOffset;
      
      // For each IH, place its L4s in a cluster below it
      Object.keys(l4sByIH).forEach((ihId) => {
        const ihL4s = l4sByIH[ihId];
        const parentIHNode = newNodes.find(n => n.id === `ih-${ihId}`);
        
        if (!parentIHNode) return;
        
        // Position L4s in a compact cluster under the parent IH
        const baseX = parentIHNode.position.x;
        const l4sPerRow = 2;
        
        ihL4s.forEach((q: any, idx: number) => {
          const nodeId = `l4-${q.id || idx}`;
          
          const row = Math.floor(idx / l4sPerRow);
          const col = idx % l4sPerRow;
          const xPos = baseX - 40 + col * 90;
          const yPos = l4Y + row * 80;
          
          newNodes.push({
            id: nodeId,
            type: 'default',
            position: { x: xPos, y: yPos },
            data: { 
              label: `L4: ${q.text?.substring(0, 20)}...`,
              fullData: q,
              type: 'l4'
            },
            style: {
              background: NODE_COLORS.l4,
              color: 'white',
              border: '1px solid #65a30d',
              borderRadius: '6px',
              padding: '5px',
              fontSize: '8px',
              width: 85,
            },
          });
          
          // Create edge to parent IH
          newEdges.push({
            id: `ih-${ihId}-${nodeId}`,
            source: `ih-${ihId}`,
            target: nodeId,
            type: 'smoothstep',
            animated: true,
            style: { stroke: NODE_COLORS.l4, strokeWidth: 0.5, strokeDasharray: '1,1' },
            markerEnd: { type: MarkerType.ArrowClosed, color: NODE_COLORS.l4 },
          });
        });
      });
      
      // Adjust yOffset
      const maxL4Rows = Math.max(...Object.values(l4sByIH).map(l4s => Math.ceil(l4s.length / 2)), 1);
      yOffset += ySpacing + (maxL4Rows - 1) * 80;
    }

    // Step 9: L6 Tasks - Hierarchical clustering under L4 nodes
    const step9 = steps.find(s => s.id === 9);
    if (step9?.output) {
      let l6Tasks: any[] = [];
      
      if (Array.isArray(step9.output)) {
        l6Tasks = step9.output;
      } else if (step9.output && typeof step9.output === 'object') {
        if (step9.output.l6_tasks) {
          l6Tasks = Array.isArray(step9.output.l6_tasks) ? step9.output.l6_tasks : [];
        } else {
          l6Tasks = Object.values(step9.output).filter(val => Array.isArray(val)).flat();
        }
      }
      
      // Group L6s by their parent L4 (based on parent_l4_id)
      const l6sByL4: Record<string, any[]> = {};
      
      l6Tasks.forEach((task: any) => {
        if (!task || typeof task !== 'object') return;
        const parentL4Id = task.parent_l4_id || task.l4_id;
        if (parentL4Id) {
          if (!l6sByL4[parentL4Id]) l6sByL4[parentL4Id] = [];
          l6sByL4[parentL4Id].push(task);
        }
      });
      
      const l6Y = yOffset;
      
      // For each L4, place its L6s in a cluster below it
      Object.keys(l6sByL4).forEach((l4Id) => {
        const l4L6s = l6sByL4[l4Id];
        const parentL4Node = newNodes.find(n => n.id === `l4-${l4Id}`);
        
        if (!parentL4Node) return;
        
        // Position L6s in a compact cluster under the parent L4
        const baseX = parentL4Node.position.x;
        const l6sPerRow = 2;
        
        l4L6s.forEach((task: any, idx: number) => {
          const nodeId = `l6-${task.id || idx}`;
          
          const row = Math.floor(idx / l6sPerRow);
          const col = idx % l6sPerRow;
          const xPos = baseX - 35 + col * 75;
          const yPos = l6Y + row * 70;
        
          newNodes.push({
            id: nodeId,
            type: 'default',
            position: { x: xPos, y: yPos },
            data: { 
              label: `L6: ${task.title?.substring(0, 18)}...`,
              fullData: task,
              type: 'l6'
            },
            style: {
              background: NODE_COLORS.l6,
              color: 'white',
              border: '1px solid #0f766e',
              borderRadius: '6px',
              padding: '4px',
              fontSize: '8px',
              width: 70,
            },
          });
          
          // Create edge to parent L4
          newEdges.push({
            id: `l4-${l4Id}-${nodeId}`,
            source: `l4-${l4Id}`,
            target: nodeId,
            type: 'smoothstep',
            animated: true,
            style: { stroke: NODE_COLORS.l6, strokeWidth: 0.5, strokeDasharray: '1,1' },
            markerEnd: { type: MarkerType.ArrowClosed, color: NODE_COLORS.l6 },
          });
        });
      });
      
      // Adjust yOffset
      const maxL6Rows = Math.max(...Object.values(l6sByL4).map(l6s => Math.ceil(l6s.length / 2)), 1);
      yOffset += ySpacing + (maxL6Rows - 1) * 70;
    }

    setNodes(newNodes);
    setEdges(newEdges);
  }, [steps, setNodes, setEdges]);

  useEffect(() => {
    buildGraph();
  }, [buildGraph]);

  const onNodeClick = useCallback((_event: React.MouseEvent, node: Node) => {
    setSelectedNode(node.data);
  }, []);

  return (
    <div className="h-full w-full relative bg-background">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onNodeClick={onNodeClick}
        fitView
        minZoom={0.05}
        maxZoom={2}
        defaultViewport={{ x: 0, y: 0, zoom: 0.5 }}
        attributionPosition="bottom-left"
        className="bg-background"
      >
        <Background color="hsl(var(--muted-foreground) / 0.2)" />
        <Controls showZoom showFitView showInteractive className="bg-card border-border" />
        <MiniMap 
          nodeColor={(node) => {
            const type = node.data?.type;
            return NODE_COLORS[type as keyof typeof NODE_COLORS] || '#6366f1';
          }}
          maskColor="rgba(0, 0, 0, 0.6)"
          style={{ background: '#1f2937' }}
        />
      </ReactFlow>

      {/* Node Details Panel */}
      {selectedNode && (
        <div className="absolute top-4 right-4 bg-card/95 backdrop-blur-sm rounded-lg shadow-xl p-4 max-w-lg max-h-[600px] overflow-auto border border-border/50">
          <div className="flex justify-between items-start mb-3">
            <h3 className="font-bold text-lg" style={{ color: NODE_COLORS[selectedNode.type as keyof typeof NODE_COLORS] }}>
              {selectedNode.label}
            </h3>
            <button
              onClick={() => setSelectedNode(null)}
              className="text-gray-500 hover:text-gray-700 text-xl leading-none"
            >
              ×
            </button>
          </div>
          <div className="text-sm space-y-2">
            {selectedNode.type === 'goal' && selectedNode.fullData && (
              <div className="space-y-2">
                <div className="bg-purple-500/10 border border-purple-500/30 p-2 rounded">
                  <p className="text-xs font-semibold text-purple-400">State Definition</p>
                  <p className="text-xs mt-1 text-foreground">{selectedNode.fullData.state_definition}</p>
                </div>
                <div className="bg-purple-500/10 border border-purple-500/30 p-2 rounded">
                  <p className="text-xs font-semibold text-purple-400">Done Criteria</p>
                  <p className="text-xs mt-1 text-foreground">{selectedNode.fullData.done_criteria}</p>
                </div>
                {selectedNode.fullData.triz_contradiction && (
                  <div className="bg-purple-500/10 border border-purple-500/30 p-2 rounded">
                    <p className="text-xs font-semibold text-purple-400">TRIZ Contradiction</p>
                    <p className="text-xs mt-1 text-foreground">{selectedNode.fullData.triz_contradiction}</p>
                  </div>
                )}
              </div>
            )}
            {selectedNode.type === 'scientific' && selectedNode.fullData && (
              <div className="space-y-2">
                <div className="bg-cyan-500/10 border border-cyan-500/30 p-2 rounded">
                  <p className="text-xs font-semibold text-cyan-400">Mechanism</p>
                  <p className="text-xs mt-1 text-foreground">{selectedNode.fullData.mechanism_summary}</p>
                </div>
                <div className="grid grid-cols-3 gap-2 text-xs">
                  <div className="bg-cyan-500/10 border border-cyan-500/30 p-2 rounded">
                    <p className="font-semibold text-cyan-400">Readiness</p>
                    <p className="text-foreground">{selectedNode.fullData.readiness_level}</p>
                  </div>
                  <div className="bg-cyan-500/10 border border-cyan-500/30 p-2 rounded">
                    <p className="font-semibold text-cyan-400">Evidence</p>
                    <p className="text-foreground">{selectedNode.fullData.evidence_strength}</p>
                  </div>
                  <div className="bg-cyan-500/10 border border-cyan-500/30 p-2 rounded">
                    <p className="font-semibold text-cyan-400">Fragility</p>
                    <p className="text-foreground">{selectedNode.fullData.fragility_score}/10</p>
                  </div>
                </div>
              </div>
            )}
            {selectedNode.type === 'ra' && selectedNode.fullData && (
              <div className="space-y-2">
                <div className="bg-emerald-500/10 border border-emerald-500/30 p-2 rounded">
                  <p className="text-xs font-semibold text-emerald-400">Requirement</p>
                  <p className="text-xs mt-1 text-foreground">{selectedNode.fullData.requirement_statement}</p>
                </div>
                <div className="grid grid-cols-2 gap-2 text-xs">
                  <div className="bg-emerald-500/10 border border-emerald-500/30 p-2 rounded">
                    <p className="font-semibold text-emerald-400">Variable</p>
                    <p className="text-foreground">{selectedNode.fullData.control_variable}</p>
                  </div>
                  <div className="bg-emerald-500/10 border border-emerald-500/30 p-2 rounded">
                    <p className="font-semibold text-emerald-400">Timescale</p>
                    <p className="text-foreground">{selectedNode.fullData.timescale}</p>
                  </div>
                </div>
              </div>
            )}
            {selectedNode.type === 'l3' && selectedNode.fullData && (
              <div className="space-y-2">
                <div className="bg-rose-500/10 border border-rose-500/30 p-2 rounded">
                  <p className="text-xs font-semibold text-rose-400">Question</p>
                  <p className="text-xs mt-1 text-foreground">{selectedNode.fullData.text}</p>
                </div>
                <div className="bg-rose-500/10 border border-rose-500/30 p-2 rounded">
                  <p className="text-xs font-semibold text-rose-400">Rationale</p>
                  <p className="text-xs mt-1 text-foreground">{selectedNode.fullData.rationale}</p>
                </div>
                <div className="grid grid-cols-2 gap-2 text-xs">
                  <div className="bg-rose-500/10 border border-rose-500/30 p-2 rounded">
                    <p className="font-semibold text-rose-400">Strategy</p>
                    <p className="text-foreground">{selectedNode.fullData.strategy_used}</p>
                  </div>
                  <div className="bg-rose-500/10 border border-rose-500/30 p-2 rounded">
                    <p className="font-semibold text-rose-400">Target</p>
                    <p className="text-foreground">{selectedNode.fullData.discriminator_target}</p>
                  </div>
                </div>
              </div>
            )}
            {!['goal', 'scientific', 'ra', 'l3'].includes(selectedNode.type) && selectedNode.fullData && (
              <pre className="bg-secondary/30 border border-border/30 p-3 rounded text-xs overflow-auto max-h-64 text-foreground select-text">
                {JSON.stringify(selectedNode.fullData, null, 2)}
              </pre>
            )}
          </div>
        </div>
      )}

      {/* Legend */}
      <div className="absolute bottom-4 left-4 bg-card/95 backdrop-blur-sm rounded-lg shadow-lg p-3 text-xs border border-border/50">
        <div className="font-bold mb-2">Legend</div>
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded" style={{ background: NODE_COLORS.q0 }}></div>
            <span>Q₀ Master Question</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded" style={{ background: NODE_COLORS.goal }}></div>
            <span>Goal Pillars</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded" style={{ background: NODE_COLORS.ra }}></div>
            <span>Requirement Atoms</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded" style={{ background: NODE_COLORS.scientific }}></div>
            <span>Scientific Pillars</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded" style={{ background: NODE_COLORS.l3 }}></div>
            <span>L3 Questions</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded" style={{ background: NODE_COLORS.l6 }}></div>
            <span>L6 Tasks</span>
          </div>
        </div>
      </div>
    </div>
  );
};
